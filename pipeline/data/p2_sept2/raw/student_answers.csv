Student,Question,Score,Answer
Andjela Markovic,1,10,"Globalni doseg-promenljive su vidljive u celom fajlu
   Doseg nioa f-je - promenljive vidljive u funkciji
   doseg prototipa f-je - f(int x, int y)
   doseg bloka- promenljive su vidljive u nekom bloku"
Andjela Markovic,2,0,"unsigned zameni(char x){
    unsigned maska=0<<sizeof(char);
    for(int i=0;i<sizeof(char);i+=2){
       x^=maska;
       maska>>=1;
      }
    return x;
}"
Andjela Markovic,3,5,"O(n), O(n)"
Andjela Markovic,4,0,Rekurzivna funkcija je funkcija koja poziva samu sebe. int f(int n){ if(n==0) return 1; return f(n-1)*f(n-1); } n=4 f(4) f(3) f(2) f(1)
Andjela Markovic,5,10,"Vremenska: O(2 na n), Prostorna: O(n)"
Andjela Markovic,6,5,"Posto se binarna pretraga koristi kod sortiranih nizova, kada proveravamo da li se neki element nalazi u tom nizu mi ga poredimo sa sredisnjim, ako je manji od sredisnjeg nalazice se u levo od srednjeg elementa, a ako je veci nalazice se desno od srednjeg elementa. Proverava se da li je 18 veci ili manji od srednjeg elementa niza, tj broja 18, posto 18 nije ni veci ni manji od 18, pa zakljucujemo da su jednaki."
Andjela Markovic,7,7.5,1. Kada ne oslobodimo memoriju koju koristimo 2. Duplo oslobadjanje memorije 3. Kada menjamo memoriju koju oslobadjamo 4. Pristup memoriji koju smo vec oslobodili
Andjela Markovic,8,3,"void moze da bude funkcija cmp, tj funkcija kojom poredimo nesto koju kasnije ukljucujemo u qsort da bi qsort znao na osnovu kog pravila da sortira "
Andjela Markovic,9,5," Stek funkcionise po principu Last In First Out, a red funkcionise po principu First In First Out. Na primerer ako hocemo da uzmemo prvu knjigu koju smo stavili na policu moramo da sklonimo sve koje smo stavili na nju da bismo je uzeli, a red funkcionise po principu reda u posti ko je prvi stigao u red prvi ce i zavrsiti."
Andjela Markovic,10,0,--
Andjela Markovic,11,10,Nacini obilazaka stabala: Preorder cvor levo desno Inorder levo cvor desno Postorder levo desno cvor Level-order po nivoima odozgo na dole
Andjela Markovic,12,0,--
Elena Golubic,1,10,"Postoje nivo datoteke(ime vidljivo u celoj datoteci), nivo bloka(vidljivo samo u okviru nekog bloka), nivo funkcije(samo u telu funkcije), nivo prototipa funkcije."
Elena Golubic,2,0,maska1 = 01010101 (za anuliranje) maska2 = 10101010(za invertovanje)
Elena Golubic,3,10,"Vremenska slozenost: O(m), prostorna: O(1)."
Elena Golubic,4,0,"Totalna rekurzija je funkcija ciji rekurzivni poziv predstavlja ujedno i konacan rezultat funkcije. Funkcija nzd je primer: int nzd(unsigned a, unsigned b){ if(b == 0) return a; return nzd(b, a%b); }"
Elena Golubic,5,10,"Vremenska slozenost je O(2^n) zbog dva poziva funkcije i umanjenja argumenata(n-1), a prostorna je O(n) jer imamo rekurziju."
Elena Golubic,6,3,"Prilikom binarne pretrage trazimo indeks elementa koji nam je dat. Inicijalizujemo u ovom slucaju levi = 0, desni = 7 i racunamo srednji indeks srednji = (levi+desni-1)/2. Proveravamo da li je element 18 sa indeksom sredji tj 3 u ovom slucaju. Posto je na srednjem indeksu element 13, a element 13 je manji od 18, pretragu nastavljamo tako sto rekurzivno pozivsamo funkciju koja na mestu desnog indeksa ima s-1, a da je broj bio veci onda bismo na mestu levog indeksa postavili s+1. Proveravaju se: 13,"
Elena Golubic,7,10,"Curenje memorije, oslobadjanje dva puta istog memorijskog bloka, pristup vec oslobodjenoj memoriji, nepravilno koriscenje pokazivaca prilikom oslobadjanja memorije(nije vrednost poziva funkcija malloc, calloc ili realloc), potkoracenje i prekoracenje bafera."
Elena Golubic,8,10,"Potpis funkcije je: void *qsort(void *array, int n, int s, int (*cmp)(const void *, const void *)). Funkcija vraca tip void, kao prvi argument ima adresu pocetka niza, a kao poslednji pokazivac na funkciju ciji su argumenti tipa const void*."
Elena Golubic,9,10,"Stek je struktura koja radi po principu LIFO(last in, first out), a red struktura koja radi po principu FIFO(first in, first out). Pomocu operacije push na vrh steka se dodaje, a pop skida sa vrha steka, a red ima dve operacije - add(dodaje na kraj reda), get(skida sa pocetka reda). Implementacija steka preko listi - funkcija dodaj_na_pocetak_liste je ekvivalent operaciji push, a funkcija obrisi_prvi_element_liste jer ekvivalent operaciji pop."
Elena Golubic,10,10,"Prvo poredimo broj 25 sa korenom 5, posto je veci idemo u desno podstablo. Poredimo ga zatim sa brojem 15, i posto je veci smestamo ga u njegovo desno podstablo, a zatim poredimo sa 29 i posto je manji od 29, smestamo ga u njegovo levo podtsablo jer smo dosli do kraja tj. nema daljeg racvanja(prazno podstablo)."
Elena Golubic,11,10,"Stablo se moze obilaziti u dubinu i u sirinu. Obilazak u dubinu moze biti infiksni(prvo se obradjuje levo podstablo, pa sam cvor, pa desno podstablo), postfiksni(prvo levo, pa desno, pa sam cvor) i prefiksni(prvo cvor, pa levo, pa desno). Obilazak u sirinu se vrsi pomocu reda. Obradi se cvor sa pocetka reda, a njegova deca se stave na kraj. Zatim obrisemo cvor sa pocetka i proveravamo da li je red prazan. Ako jeste, zavrsavamo proces, a ako nije nastavljamo od koraka 2."
Elena Golubic,12,0,--
Tijana Cirkovic,1,0,--
Tijana Cirkovic,2,0,--
Tijana Cirkovic,3,5,"Vremenska slozenost narednog koda je O,m"
Tijana Cirkovic,4,0,--
Tijana Cirkovic,5,0,--
Tijana Cirkovic,6,0,pri pretrazi proverice se broj
Tijana Cirkovic,7,0,--
Tijana Cirkovic,8,0,U generickoj funkciji qsort se koristi za sortiranje
Tijana Cirkovic,9,0,--
Tijana Cirkovic,10,0,--
Tijana Cirkovic,11,0,--
Tijana Cirkovic,12,0,--
Jovan Petkovic,1,0,hip segment stek segment podaci segment fajl segment
Jovan Petkovic,2,10,char x; unsigned maska1 = 1;unsigned maska2 =1; for(int i =0; i<(sizeof(char)*8-2) / 2;i++) { maska1<<=2; maska1=maska1 | 1; } x=x ^ maska1; maska2=maska1; maska2<<=1; x = x & ~maska2;
Jovan Petkovic,3,10,"vremenska O(m) Prostorna O(1) Program zavisi samo od m, odatle i vremenska slozenost O(m),samo jedna petlja koja ide do m Prostorna je konstantna jer su sabiranje i putchar zanemarljive."
Jovan Petkovic,4,10,"Kod totalne rekurzije ,slicno kao i totalna indukcija, nemamo jedan jedini bazni slucaj (samo nula), vec nam je potrebno vise, i za 1,2,.. na stek se postavljaju f(n), pa na njega f(n-1) pa f(n-2) i sve tako do nule pa se svi sklone i ostane samo na dnu konacna vrednost."
Jovan Petkovic,5,5,"vremenska O(2^n) Prostorna O(1) Vremenska je O(2^n) zato sto se javljaju f(n),f(n-1),... do 0 dva puta, samim tim 2^n slozenost,deljenje i ostatak su konstanti pa ne uticu. Prostorna je O(1) jer je konstantna."
Jovan Petkovic,6,10,ima 8 elemenata(indeksi od nula do 7). Znaci prvo se proverava 13 (7/2=3) zatim 19((4+7)/2=5) pa 18;
Jovan Petkovic,7,10,Curenje memorije Dvostruko oslobadjanje Zaboravljanje oslobadjanja Koriscenje oslobodjene memorije
Jovan Petkovic,8,10,"Prvo qsort je tipa void jer ne vraca nista samo sortira sta smo zadali. Pored toga koristi se u poredjenju po kom vrsimo sortiranje int poredjenje(const void *pa,const void *pb) zato sto u funkciji mi definisemo tipove, da li sortiramo intove,charove,... Pa nam void omogucava da mi podesavamo za potrebne tipove."
Jovan Petkovic,9,10,"kod steka novi podaci uvek idu na vrh, ali se i tako sklanjaju(first in, last out),prvi ce biti zatrpan novijim, dok kod reda first in, first out,odnosno ko je prvi ubacen on prvi i izlazi. stek mozemo da vidimo kod funkcije dodaj_na_pocetak u listima, gde je prvi zapravo rep, a poslednji glava."
Jovan Petkovic,10,10,"Najbitnije je da uporedjujemo vrednost cvora kojeg ubacujemo sa njegovim precima, pa ako je manji ide levo, a ako je veci desno i tako sve do kraja. Cvor *dodaj(Cvor *koren,int broj) { if (koren == NULL) return 0; if (broj> koren) dodaj(koren->desno,broj); else dodaj(koren->levo,broj); } Koraci formiranja: 25 je vece od 5, idemo desno, gledamo desno dete 25 je vece od 15 opet desno dete 25 je manji od 29, idemo levo levo nema nista znaci 25 je levo dete cvora 29 Stablo: 5 1 15 3 12 29 25"
Jovan Petkovic,11,5,"Moze po sirini i dubini. Dubina je kada idemo od korena do listova odnosno, koren pa levo/desno dete pa dalje iz tog cvora opet levo/desno(odozgo ka dole). Dok kod sirine idemo od levo ka desno. Naravno najlevlji je najmanji cvor u stablu dok je skroz desno najveci."
Jovan Petkovic,12,10,"int broj_nan(Cvor *koren,n) { if (koren == NULL) return 0; if (n == 0) return 1; return broj_nan(koren->levo,n-1)+broj_nan(koren->desno,n-1); }"
Petar Strugar,1,8,"Doseg datoteke imaju promenljive koje je moguce koristiti od kad se uvedu, pa sve do kraja programa, uglavnom su to globalne promenljive. Doseg funkcije imaju promenljive koje se uvedu u nekoj funkciji i postoje samo u sklopu te funkcije. Doseg bloka imaju promenljive koje se uvedu u nekom bloku i postoje samo u tom bloku. Doseg imaju promenljive koje su dinamicki alocirane."
Petar Strugar,2,0,"Uradimo bitovsku konjukciju sa maskom koja na neparnim pozicijama ima 0 a na parnim pozicijama ima 1, a zatim bitovsku ekskluzivnu disjunkciju istom tom maskom. rez = (x & maska) ^ maska;"
Petar Strugar,3,5,"Vremenska slozenost je O(n), a prostorna je O(n)."
Petar Strugar,4,0,Totalna rekurzija je nacin resavanja funkcije u kojoj se sem rekurzivnog poziva ne nalazi nista.
Petar Strugar,5,10,"Vremenska slozenost je O(2^(n-1)), a prostorna je O(n)."
Petar Strugar,6,10,13 pa 19 pa onda 18.
Petar Strugar,7,2,"Curenje memorije,"
Petar Strugar,8,0,--
Petar Strugar,9,0,--
Petar Strugar,10,0,--
Petar Strugar,11,0,--
Petar Strugar,12,0,--
Stevan Radivojevic,1,10,doseg datoteke - promenjiva vazi od trenutka uvodjenja do kraja datoteke dosek bloka - promenjiva vazi u bloku u kom je definisan doseg funkcije - promenjiva vazi u funkciji u kojoj je definisana doseg prototipa funkcije - promenjiva vazi u prototipu funkcije u kojem je definisana
Stevan Radivojevic,2,10,"char - 8 bitni sa x | 10101010 dobijamo broj sa svim jedinicama na neparnim mestima, dok sa ~ (x | 10101010) dobijamo broj sa svim nulama na neparnim mestima, dok su oni na parnom invertovani"
Stevan Radivojevic,3,10,"vremenska O(m), prostorna O(1)"
Stevan Radivojevic,4,10,"Kad se vrednost f(n) racuna pomocu svih prethodnih vrednosti, npr rekurzivno racunanje Katalanovih brojeva (Cn=sum_{i=0}^{n-1} Ci*C_{n-i-1}) gde su C0 i C1 date pocetne vrednosti"
Stevan Radivojevic,5,10,"vremenska O(2^n) (zato sto ako je T(n) broj operacija za poziv broja n, vidimo da je T(n)=2T(n-1) zato sto se dvaput rekurzivno poziva f(n-1)), prostorna O(n) (n poziva funkcije najvise odjednom, konstante x,y zauizimaju O(1) tako da su zanemarljive)"
Stevan Radivojevic,6,10,"a=[3,8,10,13,18,19,21,30] l=0, r=n-1=7; mid=(l+r)/2=3; a[3]=13 sto je manje od 18 sledi l=mid+1; l=4, r=7; mid=(l+r)/2=5; a[mid]=19 sto je vece od 18 sledi r=mid-1; l=4, r=4; mid=(l+r)/2=4; a[mid]=18 sto je trazeni rezultat znaci proveravaju se brojevi 13,19,18 odnosno indeksi 3,5,4 redom"
Stevan Radivojevic,7,10,- curenje memorije usred predefinisanja vec prethodno definisanje - pristupanje prethodno oslobodjene memorije - nemanje dovoljnog bloka memorije za uspesnu dinamicku alokaciju - izlazenje izvan okvira alocirane memorije
Stevan Radivojevic,8,10,"koristi se za vrstu niza koji 'prosledjujemo' u funkciju jer qsort ne sortita samo nizove jednog tipa (int, double itd), takodje se koristi kao argument funkcije poredjenja koja se prosledjuje u qsort (comp(const void *. const void *)) kao pokazivac na strukturu koju koristimo"
Stevan Radivojevic,9,10,"Stek je FIFO struktura (dodajemo na vrh i uzimamo sa vrha elemente), dok je red LIFO struktura (dodajemo na kraj a uzimamo sa pocetka). Posto za stek nam je bitno da operacije dodavanja i uzimanja sa vrha se odradjuju u O(1), mozemo samo svaki novi element predstaviti da bude nova 'glava' liste i time lako pristupamo njegovoj vrednosti, dok za skidanje sa liste dovoljno je da ga obrisemo i da nova glava bude sledeci element"
Stevan Radivojevic,10,10,"ako pretpostavimo da imamo vec napravljen taj cvor x sa definisanim brojem, onda kod ide ovako: Cvor* tren=glava; while(1) { if(x->broj >= tren->broj) { if(tren->desno!=NULL) tren=tren->desno; else { tren->desno=x; break; } } else { if(tren->levo!=NULL) tren=tren->levo; else { tren->levo=x; break; } } } prilikom dodavanja 25 prvo nailazimo na 5, vidimo da je 25>5 i da desno podstablo nije prazno tako da nam je sledeci cvor 15 kako je 25>15 i takodje vidimo da desno podstablo nije prazno, sledeci cvor nam je 29 kako je 25<29 a levo podstablo broja 29 je prazno, vidimo da 25 dodajemo kao leveog potomka od 29"
Stevan Radivojevic,11,10,"stablo se moze obilaziti u sirinu i u dubinu u dubinu: - moze se obilaziti prefiksno K-L-D (ili K-D-L) gde prvo obilazimo koren pa levo podstablo pa desno - moze se obilaziti infiksno L-K-D (ili D-K-L) gde prvo obilazimo levo podstablo pa koren pa desno podstablo - moze se obilaziti postfiksno L-D-K (ili D-L-K) gde prvo obilazimo levo podstablo pa desno podstablo pa koren primer infiksnog vodi obilazak(Cvor* koren) { obilazak(koren->levo) f(koren) //sta god da hocemo da radimo sa njim... obilazak(koren->desno) } u sirinu: - obilazimo po nivoima, gde koren definisemo kao nulti nivo, dok nivo svakog potomka definisemo kao 1 veci od nivoa njegovog pretka - to radimo tako sto dodajemo u red koren, onda uzimamo clan sa vrha reda, dodajemo u njega njegove potomke, njega samog brisemo iz reda i tako ponavljamo dok red nije prazan"
Stevan Radivojevic,12,10,"int prebroj(Cvor* koren, int k) { if(koren==NULL) return 0; //ne postoji cvor else if(k==0) return 1; else return prebroj(koren->levo, k-1)+prebroj(koren->desno, k-1); }"
Isidora Marinkovic,1,10,"Postoji doseg nivoa bloka, doseg nivoa datoteke, doseg nivoa funkcije i doseg nivoa prototipa funkcije. Doseg nivoa bloka obicno imaju globalne promenljive i funkcije. Doseg nivoa datoteke obicno imaju lokalne promenljive koje se javljaju u nekoj funkciji ili bloku funkcije. Doseg nivoa funkcije obicno imaju naredbe koje idu uz goto naredbu. Doseg nivoa prototipa funkcije imaju promenljive oblika : void funkcija(int b); znaci b ima doseg nivoa prototipa funkcije posto se samo tamo javlja."
Isidora Marinkovic,2,0,--
Isidora Marinkovic,3,10,Vremenska slozenost: O(m) Prostorna slozenost: O(1)
Isidora Marinkovic,4,0,"Totalna rekurzija je poseban oblik rekurzije u kojem je rekurzivni poziv poslednja stvar koja se izvrsava, tj posle njega se ne izvrsava nikakva druga operacija. Totalno rekurzivna funkcija je koja racuna NZD: int nzd(int a, int b) { if(b==0) return a; else return nzd(b, a%b); }"
Isidora Marinkovic,5,5,"Vremenska slozenost: imamo jedno if koje kada je n jednako 0 vraca 1 to gledamo kao O(1), imamo promenljivu x koja radi n%3 isto gledamo kao O(1), onda za y isto O(1), na kraju imamo rekurziju i to dva puta pozvanu koja je pomnozenasa x i y sto znaci da je njena slozenost O(2^n). Ukupna vremenska slozesnost je O(2^n). Prostorna slozenost: gledam kakva promenljive imamo to su x i y kojima je slozenost O(1), zatim imamo dodelu kod x i y to isto gledamo kao O(1), a na kraju imamo rekurziju zbog koje se stvara stek okvir i koja je dva puta pozvana znaci njena slozenost je O(n^2). Dakle ukupna prostorna slozenost je: O(n^2)."
Isidora Marinkovic,6,0,"[3, 8, 10, 13, 18, 19, 21, 30] Binarnom pretragom pretrazuje se broj 18 u zadatom nizu, brojevi koji se proveravaju pri ovoj pretrazi su svi manji od njega."
Isidora Marinkovic,7,10,"Greske koje se javljaju su: curenje memorije, fragmentisanje memorije, oslobadjanje pogresnog pokazivaca, oslobadjanje vec oslobodjene memorije (tj oslobadjanje oslobodjene memorije vise puta), prekoracenja i potkoracenja bafera."
Isidora Marinkovic,8,10,"void qsort(void *a, size_t n, size_t size, int (comp *) (const void *pa, const void *pb)); qsort je void zato sto moze da sortirate proizvoljne elemente. Prvi clan je tipa void jer on takodje moze biti proizvoljan i to je ono sto sortiramo. Kod funkcije poredjenja koristimo const void *, jer su nam to pokazivaci na elemente koje poredimo."
Isidora Marinkovic,9,8,"Stek - LIFO (""last in, first out""). Postoje dve operacije: dodaj na stek i skini sa steka. Dodaj na stek dodaje na vrh steka, a skini sa steka skida sa vrha steka. Red - FIFO (""first in, first out""). Postoje dve operacije: dodaj u red i skini sa reda. Dodaj na red dodaje na kraj reda, a skini sa reda skida sa pocetka reda. To je njihova razlika. Implementiramo stek preko listi funkcijom koja dodaje element na pocetak liste."
Isidora Marinkovic,10,0,
Isidora Marinkovic,11,10,Obilazak stabla u sirinu je obilazak stabla po nivoima. Obilazak stabla u dubinu je sledeci: -infiksni - L-K-D (levo podstablo-koren-desno podstablo) ili D-K-L -prefiksni - K-L-D ili K-D-L -postfiksni - L-D-K ili D-L-K
Isidora Marinkovic,12,0,"Cvor *cvorovi_na_ntom_nivou(Cvor *koren, int n) { if(n==0) return koren; Cvor *levi = cvorovi_na_ntom_nivou(koren->levo, n-1); Cvor *desni = cvorovi_na_ntom_nivou(koren->desno, n-1); return levi > desni ? levi+1 : desni+1; }"
Neda Samardzic,1,10,doseg nivoa datoteke doseg nivoa bloka doseg nivoa funkcije doseg nivoa prototipa funkcije
Neda Samardzic,2,0,x=((x&(~1))<<2)
Neda Samardzic,3,0,vremenska je O(n/3) prostorna je O(n)
Neda Samardzic,4,5,Fibonacijev niz npr za fib(4): fib(4) - fib(3) -fib(2) -fib(1) -fib(0) -fib(1) - fib(2) -fib(1) -fib(0)
Neda Samardzic,5,10,"vremenska slozenost O(2^n) prostorna sozenost O(n) x i y ne uticu, i onda imamo T(n)=2*T(n-1)=2*2*T(n-2)=...=2^n*T(0)=2^n*1=2^n"
Neda Samardzic,6,10,"proveravaju se 13 19 i 18 niz se presece na pola -> 13 gledamo -> 13 je manje od 18 znaci ne gledamo levu stranu niza vise, pomeramo levu granicu, opet secemo niz na pola -> 19 -> vece od 18, pomeramo desnu granicu, gledamo sredinu niza -> 18 , broj koji smo i trazili"
Neda Samardzic,7,7.5,"-moramo proveriti da li se dobro alocirala memorija, jer se moze desiti da nije - ne smemo zaboraviti da kastujemo jer su i malloc i calloc tipa void* znaci moramo eksplicitno napisati npr p=(int *)malloc(sizeof(int)*8); - moramo pravilno osloboditi dinamicki alociranu memoriju da se ne bi ""zauvek"" izgubila"
Neda Samardzic,8,3,kod pokazivaca na funkcije
Neda Samardzic,9,6,"stek mozemo da poistovetimo sa slaganjem gajbica voca, onu koji smo poslednju stavili, nju cemo prvu skinuti i slaganje ide od dle ka gore kao kolona neka, LIFO (last in, first out) dok red mozemo poistovetiti sa kupcima koji dolaze po gajbice npr, prvi koji dodje prvi ce i da ode, poslednji koji dodje poslednji ce i da ode, i to je kao vrsta, FIFO (first in first out)"
Neda Samardzic,10,0,--
Neda Samardzic,11,8,"stablo se moze obici prefiksno, infiksno i postfiksno prefiksno obilazenje - uobicajeno k-l-d (a moze i k-d-l) prvo koren, levi cvorovi , pa desni (prvo koren, desni cvorovi pa levi) infiksno - uobicajeno l-k-d (a moze i d-k-l) prvo levi cvorovi pa koren pa desni (desni cvorovi, koren, levi) postfiksno - uobicajeno l-d-k (a moze i d-l-k) prvo levi cvorovi, pa desni, pa koren (desni cvorovi, levi, pa koren)"
Neda Samardzic,12,0,--
Nevena Matejic,1,10,1.dosek datoteke 2. dosek funkcije 3. dosek bloka 4. dosek prototipa funkcije
Nevena Matejic,2,0,void izmeni(char x) { //unsigned velicina = sizeof(char) - 1; maska = while(x != 0) { x = x ^ 1; one na parnim pozicijama sa ekskulzivnom disjunkcijom invertujemo x = x>>= 2 ; siftujemo za 2 u desno i time prescacemo bit na neparnoj poziciji samim tim da izbacujemo } }
Nevena Matejic,3,10,"Vremenska slozenost O(m), prostorna slozenost O(1);"
Nevena Matejic,4,0,"Totalna rekurzija je tip rekurzije koja se ne moze eliminisati. Repna rekurzija je ona kod koje je rekurzivni poziv ujedno i konacan rezultat funkcije, tj nemamo naredbe nakon toga pa se on moze implementirati i iterativno, tj eliminisati."
Nevena Matejic,5,5,"Vremenska slozenost O(1), prostorna slozenost O(n);"
Nevena Matejic,6,0,"Binarna pretraga zahteva da niz bude sortiran. Ovde je dimenzija niza 8 i prva stvar je da se nadje indeks sredisnjeg elemente i proveri da je on mozda trazeni element. srednji = n/2; a[srednji] = 18? niz: 3, 8, 10, 13, 18, 19, 21, 30 indeks: 0, 1, 2, 3, 4, 5, 6, 7 srednji je u ovom slucaju 4 a na a[4] nalazi se bas 18, pa nema potreba za ispitivanje levog ili desnog podniza. Dakle proverava se samo 18."
Nevena Matejic,7,10,"1.Curenje memorije 2.Neoslobadjanje dinamicki alocirane memorije 3.Ponovno oslobadjanje / Oslobadjanje vec oslobodjenog bloka memorije 4.Sporija implementacije, npr. kod niza nije nam poznata gornja granica dimenzije niza, pa ako je dinamicki alociramo mozemo alocirati ili preveliki blok memorije ili sekvencijalno dodavati odredjeni deo."
Nevena Matejic,8,10,"Povratna vrednost bibliotecke funkcije za sortiranje nizova je tipa void*. Takodje u prototipu funkcij qsort imamo pokazivac na funkciju tipa int koja ima argumente tipa const void*. Ona nam govori o nacinu na koji poredimo dva elemente niza, vraca 1/-1 u zavisnost da li hocemo neopadajuce/nerastuce sortiran niz i vraca 0 ako ako su elementi jednaki. Void je genericki tip i omogucava nam da koristimo razlicite tipove podatka. Takodje kastovanjem tip void* mozemo promeni na tip podataka koji nam u tom trenutku treba."
Nevena Matejic,9,7.5,"Stek radi po principu LIFO(last in-first out) tj. na stek se mogu dodavati stek okviri nekih instanca funkcija i skidaju se sa steka u obrnutom redu od kojeg su postavljeni, tj. posledni stek okvir ce biti prvi uklonjen. Red radi po principu FIFO(first in-first out). Primer: red kod zubara tj. poslednja osoba u redu ce poslednja otici na pregled. Kod reda imamo dva pokazivaca, najcesce jedan pokazivac koji pokazuje na pocetak reda i jedan koji pokazuje na kraj. Implementacija steka preko liste: Dodavanje novog stek okvira odgovara dodavaju novog cvora na kraj liste. Poslednji cvor u pocetnoj listi pa njegov pokazivac vise ne pokazuje na vrednost NULL nego na novi, upravo dodati cvor i u tom smislu ce novi element postati poslednji. Skidanje sa steka odgovara brisanju cvorova sa kraja liste. Prethodni element sada postaje poslednji pa njegov pokazivac na sledeci sada pokazuje na NULL."
Nevena Matejic,10,5,"Svaki cvor ima pokazivac na prethodni i naredni cvor. Kako je stablo uredjeno, mozemo da nadjemo mesto umetanja elementa i preusmetiti pokazivace. 5 koren 1 < 5 ide levo od 5 3 <5, >1 ide od cvora 1 desno 15> 5, >3 pa je to desna grana korena 5 12 <15, > 5 pa je to desna grana cvora 3 25 > 15 to je desna grana cvora 15 i 29 list desna grana cvora 25"
Nevena Matejic,11,7.5,"1. obilazak stabla u sirinu 1.1 infiksni((L, K, D) ili (D, K, L)) 1.2 prefiksni((K, L, D) ili (K, D, L)) 1.3 postfiksni(L, D, K)"
Nevena Matejic,12,0,--
Anastasija Rasic,1,10,"Postoji 4 dosega: doseg datoteke,bloka, funkcije, prototipa funkcije, Doseg datoteke je doseg koju promenljiva ima kada se uvede na pocetku datoteke i vidljiva je i moze da se iskoristi u celoj datoteci. Doseg bloka ima funkcija koja se koristi samo unutar bloka u kojem je uvedena i tu je samo vidljiva. Doseg prototipa funkcije imaju promenljive koje se nalaze u prototipu funkcije. Doseg funkcije imaju promenljive koje su uvedene i koriste se u samo u toj funkciji."
Anastasija Rasic,2,0,"treba da svaka parna cifra suprotna ,svaka neparna 0 int funkcija(char x){ unsigned char maska = 2 ; //maska = 0000 0010 while(maska){ x = x & ~maska; maska << 2; } }"
Anastasija Rasic,3,10,vremenska slozenost : O(m) prostorna slozenost: O(1)
Anastasija Rasic,4,0,"Totalna rekurzija je rekurzija koja pri return poziva samu sebe bez dodatnog sabiranja, mozenja ili bilo cega. Primer: void f(int x){ if(x == 0) return; printf(""%d\n"", x); return f(x-1); } Ova funkcija ispisuje sve brojeve manje od x. Stek okvir za f(4): f(1) f(2) f(3) f(4) Svaki rekurzivni poziv dodajemo na vrh i prilikom izvrsavanja prvo se od zavrsava i zatvara."
Anastasija Rasic,5,5,"Vremenska slozenost O(n), prostorna slozenost O(n na kvadrat) Vremenska slozenost je n je imamo rekurziju ali je broj rekurzija jednak broju n jer se n u svakom rekurzivnom pozivu smanjuje za jedan. Prostorna slozenost je n na kvadrat tj. veoma je velika jer pri svakom rekurzivnom pozivu mi imamo medjurezultate koje moramo da cuvamo."
Anastasija Rasic,6,10,"Prilikom binarne pretrage krecemo sa proverom od srednjeg clana sto je ovde 13 pa se onda gleda desna polovina niza i opet se krece od sredine sto je 19 i tek se onda dolazi do 18 Proveravaju se : 13, 19, 18"
Anastasija Rasic,7,10,"Curenje memorije, fragmentisanje memorije, pristupanje memoriji koja nije alocirana i pristupanje vec oslobodjenoj memoriji"
Anastasija Rasic,8,5,"Void je neoznaceni tip podataka jer pomocu qsort mi mozemo da sortiramo bilo koji tip podataka a ne samo jedan i to nam void omogucava da prilikom njegovog poziva mi izaberemo tip koji sortiramo i po kom nacinu sortiramo(rastuce, opadajuce brojeve ili leksikografski niske itd.)."
Anastasija Rasic,9,5,"Razlika izmedju steka i reda je u tome sto je red tipa LILO (last in last out) u znacenju da se na red dodaje na kraj a ""uzima"" sa pocetka, dok kod steka imamo LIFO (last in frist out) sto znaci da mi mozemo da iz steka uzmemo samo zadnji dodat podatak i da mozemo da dodamo samo sa kraj. Stek se preko listi moze implementirati tako da dodavanje u stek predstavlja dodavanje zadnjeg clana liste, a brisanje iz steka predstavlja brisanje zadnjeg clana liste."
Anastasija Rasic,10,5,"void dodaj_cvor(Cvor * koren, int broj){ Cvor *novi = napravi_cvor(broj); if(novi == NULL) return; if(koren->vrednost > broj) return dodaj_cvor(koren->desno, broj); else if(koren->vrednost < broj) return dodaj_cvor(koren->levo, broj); }"
Anastasija Rasic,11,10,"Obilazak stabla se moze vrsiti po sirini i dubini. Obilazak stabla po dubini predstavlja to da se krene od korena stabla i ide se do najdaljeg lista i to ce biti njegova najveca dubina. Sa dubinom stabla se zapravo citaju prvo koren pa njegovi potomci. Obilazak stabla u sirinu predstavlja obilazak stabla na nekom itom nivou. Ako ispisujemo stablo onda imamo i tri nacina na koje mozemo to da uradimo: prefiksno: koren pa potomci infiksno levi potomak, koren, desni potomak postfiksno: levi i desni potomak pa koren"
Anastasija Rasic,12,10,"int broj_cvorova_na_ntom_nivou(Cvor *koren, int n){ if(koren == NULL) return 0; if(n == 0) return 1; return broj_cvorova_na_ntom_nivou(koren->levo, n-1) + broj_cvorova_na_ntom_nivou(koren->desno, n-1); }"
Lazar Markovic,1,7.5,"1. global scope, u ovom dosegu se nalaze globalne promenljive, tj promenljive koje nisu definisane unutar neke funkcije vec u samom programu. 2. local scope, u ovom dosegu su lokalne promenljive i promenljive koje predstavljaju paramtre funkcija 3. scope samo za definiciju promenljivih (potpis) npr. int f (char c);. 4."
Lazar Markovic,2,10,(~x) & 01010101
Lazar Markovic,3,10,vremenska slozenost je m/3 jer se u svakoj iteraciji petlje i povecava za 3 (jednom u for defniciji i jednom se povecava za 2 unutar samog fora). vremenska: O(m/3) = O(m) prostorna slozenost je O(1) jer nam nije potreban nikakav pomocni prostor osim izlaznog i ulaznog.
Lazar Markovic,4,0,Totalna rekurzija je kada funkcija u svakom toku rada poziva samu sebe. void f() { cout << 'a'; f(); }
Lazar Markovic,5,5,"T(n) = 2 (za racunanje n%3 i za dodeljivanje vrednosti x) + 3 (za racunanje n/10, (n/10)%5 i dodeljivanje te vrednosti y) + T(n - 1) + 1 (za racunanje f(n - 1) i mnozenje) + T (n - 1) + 1 (isto, samo za desnu stranu) + 2 (za return i sabiranje) + 1 (za proveru u baznom slucaju) + 1 (return u baznom slucaju) T(n) = 2 + 3 + 2 * T(n - 1) + 2 + 2 + 2= 2 * T(n - 1) + 11 odakle dobijamo da je slozenost asimptotski jednaka O(2^n)."
Lazar Markovic,6,10,"l = 0, d = 7 => s = (l + d)/2 = 3, broj na poziciji 3 je 13. 13 < 18 => l = s + 1 = 4 l = 4, d = 7 => s = (l + d)/2 = 5, broj na poziciji 5 je 19. 19 > 18 => d = s - 1 = 4 l = 4, d = 4 => s = (l + d)/2 = 4, broj na poziciji 4 je 18. 18 == 18. pronasli smo broj 18. brojevi koji se proveravaju su 13, 19, 18"
Lazar Markovic,7,10,"Greske koje se javljaju su: 1. curenje memorije, koje se javlja kada se ne oslobodi neka merorija koja je dodeljena (kada programer zaboravi, ili negde u zadatku izgubi vrednost pokazivaca). 2. pristup vec oslobodjenoj memoriji, kada se na neki pokazivac p primeni free(p), a kasnije u programu koristi kao da jos sadrzi validnu vrednost. 3. oslobadjanje vec oslobodjene memorije, nastaje kada pokusamo da primenimo free(p) na neki pokazivac p na koji je free vec bilo primenjeno. 4."
Lazar Markovic,8,10,"U funkciji qsort tip void se koristi za prenos pokazivaca na niz koji treba sortirati jer mozemo sortirati razlicite tipove podataka (int, char, struct...), i za prenos pokazivaca na funkciju koja sluzi za poredjivanje."
Lazar Markovic,9,10,"Razlika izmedju stekova i redova je u tome sto se stekovi prazne sa iste strane na koju se i pune tj LIFO (Last In First Out), dok se redovi prazne sa suprotne strane tj FIFO (First In First Out). Stek bi se preko dvostruko povezanih listi implementirao tako sto pamtimo pokazivac na poslednji elemenat liste. Kada zelimo da ubacimo novi element na listu, njegovu lokaciju dodajemo u polje next trenutnog zadjeg elementa, i u njegovo polje previous ubacujemo trenutnu vrednos pokazivaca na poslednji element, i pokazivac na poslednji element stavljamo da pokazuje na lokaciju novog elementa, Za popovanje elementa prvo proveravamo da li je stek prazan (pokazivac na zadnji element != NULL). Ako nije prazan u polje next pretposlednjeg elementa upisujemo NULL (do njega dolazimo kao posledji->prev->next) i updatujemo pokazivac na posedji element da bude jednak poslednji->prev (pretposlednji element). Ako su pokazivaci na prvi i poslednji element jednaki i popujemo, pokazivace treba postaviti na NULL jer je lista prazna. Kada bi ponovo dodavali elementa prvo bi morali da dodelimo vrednost pokazivacu na prvi."
Lazar Markovic,10,7.5,"void dodaj(cvor* koren, int n) { if (koren->broj > n) { if (koren->levi) dodaj(koren->levi, n); else koren->levi = new cvor(n); } else { if (koren->desni) dodaj(koren->desni, n); else koren->desni = new cvor(n); } }"
Lazar Markovic,11,10,"Nacini obilaska stabla su: 1. Inorder obilazak, prvo obidjemo levo podstablo cvora, sam taj cvor, i na kraju desno podstablo. 2. Postorder obilazak, prvo obidjemo levo podstablo cvora, onda desno podstablo, i na kraju sam taj cvor. 3. Preorder obilazak, prvo obidjemo cvor, onda njegovo levo podstablo, i na kraju njegovo desno podstablo. 1. void obidji(cvor* a) { if(!a) return; obidji(a->levo); cout << a->ime; obidji(a->desno); } 2. void obidji(cvor* a) { if(!a) return; obidji(a->levo); obidji(a->desno); cout << a->ime; } 3. 2. void obidji(cvor* a) { if(!a) return; cout << a->ime; obidji(a->levo); obidji(a->desno); }"
Lazar Markovic,12,10,"int cnt = 0; void prolaz(int n, int nivo, cvor* koren) { if(!koren) return; nivo++; if (n == nivo) cnt++; prolaz(n, nivo + 1, koren->levo); prolaz(n, nivo + 1, koren->desno); }"
Nikola Popovac,1,0,
Nikola Popovac,2,10,char x; char maska = 1; int i = 0; while(i < 3) { maska << 2; maska += 1; i++; } x = x & maska; maska = ~maska; x = x ^ maska;
Nikola Popovac,3,0,Vremenska O(m/2) Prostorna O(m)
Nikola Popovac,4,0,--
Nikola Popovac,5,10,Prostorna O(n^2) Vremenska O(n)
Nikola Popovac,6,10,"Posto za l uzimamo 0 i za d uzimamo 8 - 1, znamo da je sredina (0 + 7) / 2 = 3. Prvi element koji se proverava je 13, jer je on ima indeks 3. Kako je on manji od 18, sledi l = sredina + 1 = 4. Nova sredina je jednaka 5. Drugi element koji se proverava je 19, ima indeks 5. On je sada veci od 18, pa se sada pomera desna granica, tj. d = sredina - 1 = 4. Nova sredina je 4. Sedeci element koji se proverava je 18, ima indeks 4. Kako je on bas onaj trazeni, vraca se vrednost sredine, tj. 4. Dakle, pri ovoj pretrazi proveravaju se 13, 19 i 18."
Nikola Popovac,7,2.5,Jedna od gresaka se moze desiti kada alociramo memoriju jeste ta da na kraju programa ne oslobodimo alociranu memoriju funkcijom free(). To se naziva curenje memorije ili memory leak.
Nikola Popovac,8,5,"U qsort funkciji tip void se koristi u pomocnoj funkciji koja poredi dva elementa. To je npr. funkcija int cmp(contst void *a, const void *b). Kako pomocu qsort mozemo sortirati razlicite tipove podatka, void sluzi kako bi smo mogli da ""kastujemo"" te tipove."
Nikola Popovac,9,0,--
Nikola Popovac,10,10,"Nase stablo izgleda: 5 1 15 3 12 29 Kada u njega dodamo 25: 5 1 15 3 12 29 25 Prvo se proverava da li je 25 vece od vr. korena. Kako je 25 vece od 5, proverava se da li je desno dete razlicito od NULL, ako jeste proverava da li je vece od vr. koja se nalazi desno od korena, tj. 15. Kako je vece, ponavlja se isti proces. Sada, 25 nije vece od 29, pa se proverva da li je levo dete razlicito od NULL. Posto jeste NULL, tu se pravi novi cvor i postavlja se vr. na 25."
Nikola Popovac,11,0,"Stablo mozemo obici na vise nacina. Npr mozemo krenuti od najlevljeg cvora i doci do korena, a zatim idemo do najdesnijeg cvora. Takodje mozemo krenuti obrnutim redosledom."
Nikola Popovac,12,0,--
Andrea Cvetanovski,1,10,"1 Doseg nivoa datoteke: promenljiva vazi u celoj datoteci, u svim funkcijama tj od pocetka programa do kraja programa se moze koristiti. To su globalne promenljive. 2 Dosek nivoa bloka promenljiva koja ima doseg nivoa bloka se moze koristiti samo tokom odredjenog bloka. to moze biti petlja , funkcija... to su promenljive u telu funkcije ili u for, while ili dtugoj petlji 3 Doseg nivoa funkcije imaju samo labele za goto naredbu 4 Dosek nivoa prototipa funkcije: ovaj doseg imaju samo formalne promenljive koje se koriste pri deklaraciji funkcije najvazniji su doseg nivoa datoteke i doseg nivoa bloka. promenljive koji su dosega nivoa datoteke se nazivaju spoljasnje ili glonbalne, dok se promeljive ostalih tipova nazivaju unutasnje."
Andrea Cvetanovski,2,8,"char pretvori(char x){ char maska1 = ~0; char x1 = maska znak za ekskluzivnu disjunkciju(nisam mogla da nadjem) maska1; char maska2 = 1; char rezultat; while(maska2 != 0){ rezultat = x1 & maska2; maska2<<=2; } return rezultat; } Ovde smo prvo invertovsli sve bitobve sa maskom1 jer nam nije vazno svakako sta ce biti na prarnim pozicijama jer cemo kasnjije postaviti nulu, a sa drugom maskom u svakom prolazu kroz while petlju postavljamo nulu sa leve strane na svako drugo mesto sto je uredu jer numerisanje krece sa desne strane i krece cifrom 0 koja je parna."
Andrea Cvetanovski,3,10,"Vremenska slozenost je O(m), a prostorna je O(1) ne koristi se nikakva dodatna memorija pa je prostoran slozenost konstantna , a sto se vremena tic imamo samo jednu for petlju kroz koju prolazimo dok je i manje od m i se pri svkom prolaskiu povecava za 3 , ali posto se aditivne i multiplikativne konstante zanemaruju pri odredjivanju slozenosti programa, slozenost je linearna."
Andrea Cvetanovski,4,0,"Totalna rekurzija je rekurzija u kojoj se vakim koriscenjem rekurzivne funkcije ponovo poziva ista funkcija ,a izlazi se iz funkcije tek kad se dodje do baznog slucaja. primer je na primer racunanje stepena 2, tj za zadati broj racunamo 2 na taj steopen. int racunanje_stepena2(int broj){ if(broj = 0) return 1; return 2* racunanje_stepena2(broj-1); } stek okvir za recimo 3 bi izgledaoo tako da je na dnu stek okvir za 3 pa iznad za 2 pa iznad za 1 i na kraju za 0 pa bi se prvo racunala 2 na 0 sto j bazni slucaj pa bi vratilo jedan u poziv sa 2 i tako dalje do dna."
Andrea Cvetanovski,5,5,"vremenska slozenost je O(2 na n-ti stepen) zbog 2 rekurzivna pozaiva pri za svaku vrednost, a prostorna slozenost je O(1) jer se ne koristi dodatna memorija, nema dodatnih nizove, imamo samo dv promenljive koje ne menjaju memorijsku potrosnju bitno."
Andrea Cvetanovski,6,10,"Pri toj pretrazi se proveravaju brojevi 13 19 i posle toga se pronalazi 18 koji je izmedju njih. jer se binarnom pretragom interval polovi i uzima se ona strana kojoj pripada taj broj, a o znamo jer je niz sortiran."
Andrea Cvetanovski,7,10,greske: visestruko oslobadjanje iste memorije curenje memorije nepravilno oslobadjanje memorije (u smislu da ako je p pokazivac na zauzetu memoriju nije ispravno oslobadjati p+10) oslobajanje memorije koja nije dinamicki alocirana
Andrea Cvetanovski,8,10,void se koristi za promenljive u funkciji(pokazivac na funkciju je tipa int jer uvek vraca celobrojnu vrednost) kojom se dva elementa uporedjuju da bi funkcija mogla da se koristi za razlicite tipove takodje pokazivac na niz je tipa void da bi se qsort koristio za sve vrste nizova Void se koristi u qsortu kako bi se ta funkcija mogla kosristiti za bilo koj tip pa cak i9 za strukturu
Andrea Cvetanovski,9,10,"stek je tipa lifo tj last in first out dodavanje na stek se vrsi dodavanjem na vrh steka , a uzimanje tj sklananje sa steka se vrsi uzimanjem sa vrha steka do je ret tipa fifo tj first in first out tj dodaju se elemnti na kraj reda a uzimaju sa pocetka reda, tj ono sto prvo udje u red mora prvo i da izadje. stek se moze implementirati preko niza i liste preko liste: dodavanje na vrh steka je kao dodavanje na pocetak liste, a uzimanje sa steka(sa vrha steka) je kao uzimanje elementa sa pocetka liste."
Andrea Cvetanovski,10,5,"Cvor se dodaje u uredjeno stablo tako sto sepostavlja tako da su brojevi levo od njega manji ofd njega a brojevi desno od njega veci od njega. prvo uporedjujemo broj koji hocemo da dodamo sa korenomstabla, ukoliko je manje od njegfa uporedjujemo sa korenom lovog podstabla , a ukolikio je vece sa korenomdesnog podtabla, kad kazem koren u ovom sluvaju mislim na element na najvisem nivou odredjenog podstabla i tako rekutzivno nastvljamo da trazimo poziciju. U ovom slucaju 25 se oddaje na 29 tako sto se napravileva grana na cvor sa vrednoscu 29 jer je manje od 29 a vece od svih ostalih elemenata stabla. znaci prvo bismo uporedjivali sa korenom i vidimo da je 25 vece od 5 sto je u ovom slucsju koren, pretrazujemo desno stablo,uporedjujemo sa 15 i vidimo da je i od njega vece, pa pretrazujemo desno podstablo, immoa samo 29 koje je list . vidimo da je 25 manje od dvadesed devet pa pravimo cvor levo od njega i tu upisujemo vrednost 25."
Andrea Cvetanovski,11,10,"Stablo se moze obilatziti u sirinu i dubinu. U dubinu moze biti infiksno(lkd i dkl)to je obilazak gde se prvo prelazi jedno podstablo onda koren pa drugo podstablo, moze biti prefiksno(kdl i kld)obilazi se prvo koren pa podstabla i postfiksno(ldk i dlk) obilaze se prvo podstabla pa onda koren . ukoliko je npr ldk onda se obilazi levo pa debo podstablo i ona koren. u sirinu se prelazi po nivoima tj prvo koren pa deca korena pa zatim nivo na kojem su deca prethodnog nivoa i tako dalje . u sirinu se moze opisati redom tako sto se u red prvo ubacuje koren. obradjujemo element koji je na pocetku i ubacujemoi na kraj reda njegovu decu. Izbacimo iz reda element koji smo obradili . i ako red tada prazan to je kraj obilaska ,a ako nije obradjujemo prvi element i nastavljamo postupak."
Andrea Cvetanovski,12,0,--
Katarina Simojlovic,1,0,--
Katarina Simojlovic,2,5,"Kreiramo masku = 1 << (sizeof(char) * 8 - 1), zatim uporedjujemo masku i char x, ako je bit na parnoj poziciji pisemo x , a ako je bit na neparnoj poziciji pisemo x ^ maska, i time invertujemo bit. Masku pomjeramo ulijevo dok ne postane nula. x = 1001 1100 1010 1111 m = 1000 0000 0000 0000"
Katarina Simojlovic,3,5,"Vremenska slozenost koda je O(n) (linearna), a prostorna slozenost koda je takodje O(n)."
Katarina Simojlovic,4,5,Totalna rekurzija je oblik rekurzivne funkcije u kom se citava funkcija svodi na bazni slucaj i rekurzivni oblik. Primjeri ovakve rekurzije su npr. funkcije pronalska NZD dva broja ili funkcija koja racuna faktorijel broja n. int faktorijel(int n) { if(n == 1) return faktorijel; return n * faktorijel(n - 1); } Za f(3) imamo: f(3) | | n * f(2) | | n * f(1)
Katarina Simojlovic,5,10,"Vremenska slozenost funkcije je O(2^(n - 1)), a prostorna slozenost je jednaka dubini steka, odosno O(n) T = x * (T - 1) + y * (T - 1) x = n%3; y = (n/10)%5"
Katarina Simojlovic,6,10,"Niz [3,8, 10, 13, 18, 19, 21, 30] se polovi i ako je polovina manja od trazenog broja gledamo lijevu u suprotnom desnu stranu. Broj 18 se nalazi na i = 4 poziciji, polovina ce biti 13 pa gledamo desnu stranu niza. Tu je polovina 19, pa gledamo lihjevu stranu drugog niza i nalazimo 18."
Katarina Simojlovic,7,5,"Prilikom dinamickog alociranja memorije, greske koje se mogu desiti su: curenje memorije odnosno ne oslobadjanje alocirane memorije (free), mzoe se desiti greska prilikom ealociranja memorije,"
Katarina Simojlovic,8,5,"Funkciju void koristimo prilikom deklarisanja funkcije po kojoj qsort treba da sortira niz, odnosno funkcije koja objasnjava sta se sortira i po cemu, i ona se nalazi na kraju poziva qsort."
Katarina Simojlovic,9,10,"Stek je struktura podataka koja se izvrsva na principu ""first in last out"", dok je red struktura podataka koja se izvrsava na principu ""first in first out"". Obje strukture imaju operacije dodavanja elementa i brisanja koje su slozenosti O(1), Da bismo implementirali stek koristeci jednostruko povezanu listu, kreiraili bismo strukturu cvor koja opisuje jedan cvor liste i koji sadrzi pokazivac na sledeci element liste. Da bismo dodali element na pocetak steka, koristili bismo funkciju za dodavanje clana na pocetak liste, odnosno mijenjanje glave liste, a da bismo obrisali element, brisemo glavu liste i sledeci postaje nova glava."
Katarina Simojlovic,10,0,"Funkciju mozemo implementirati na sledeci nacin: ako je pokazivac na korijen razlicit od nule i u zavsinosti da li korijen ima oba potomka, skeniramo vrijednosti cvora i stavljamo ih u lijevi ili desni cvor u zavisnosti od njihove vrijednosti (u uredjenom stablu stavljamo manji potomak u lijevi, veci u desni cvor)."
Katarina Simojlovic,11,10,"Da bismo obisli stablo to mozemo uraditi: -infiksno: princip L-K-D, prolazimo kroz jedan potomak, korijen, drugi potomak -postfiksno: L-D-K ili D-L-K, prolaizmo prvo kroz potomke zatim kroz korijen -prefiksno: K-L-D ili K-D-L, prvo prolazimo kroz korijen zatim njegovo lijevo potom desno stablo Stablo takodje mozemo obici u sirinu, koristeci strukturu red."
Katarina Simojlovic,12,0,--
Aleksandra Rogova,1,8,"dosed nivoa datoteke, dosek nivoa bloka, doseg nivoa funkcije, doseg nivoa ime funkcije"
Aleksandra Rogova,2,10,for(int i = 0; i < 8; i++){ if(i % 2 == 0) x~= (1U << i); else x &= ~(1U << i); }
Aleksandra Rogova,3,10,"vremenska slozenost je m, prostorna je 1"
Aleksandra Rogova,4,0,-
Aleksandra Rogova,5,10,vremenska slozenost je 2^n zbog imamo rekurivnu vezu koje se zove 2 puta prostorna slozenost je n/10 dubina rekurzivnoj funkcije je n
Aleksandra Rogova,6,8,"13, 18 (levo= 0, desno = n -1, sredina = (levo + desno) / 2 ==> n[sredina] = 13, n[sredina] < 18 ==> levo = sredina - 1 ==> n[sredina] = 18)"
Aleksandra Rogova,7,7.5,"fragmentcija memorije, curenije memorije, stack overflow,"
Aleksandra Rogova,8,5,"qsort(niz,n, sizeof(TYPE), poredi) kod funkcije poredjenja int poredi(const void *a, const void *b) zbog mozemo koristi bilo sta kod ovoj funkcijje : nizovi tipa int, niske, structure, karaktere"
Aleksandra Rogova,9,3,"stek : prvi usao, prvi izasao red : prvi usao, poslednji izasao"
Aleksandra Rogova,10,0,"void dodaj(Cvor *koren, int broj){ if(broj > koren->vrednsot) dodaj(koren->desno, broj) if(broj < koren->vrednost); dodaj(koren->levo, broj); } 5 < 25 => idemo levo, 15 < 25 => levo, 25 < 29 => dodaj pre njega sa desno od prethodnog korena"
Aleksandra Rogova,11,7.5,"postfikcsno LDK (prvo leva grana, nakon desna grana i potom koren stabla) insfiksno LKD (leva grana, koren stabla i potom desna grana) prefiksno KLD(prvo koren stabla, nakon leva grana i potom desna)"
Aleksandra Rogova,12,0,int cvorova_n(Cvor *koren){ if(koren->desno != NULL || koren->levo == NULL) return 1 + cvorova_n(koren->desno); else if(koren->desno == NULL && koren->levo != NULL ) return 1 +cvorova_n(koren->levo); else if(koren->desno != NILL && koren->levo != NULL) return 1 + cvorova_n(koren->levo) + cvorova_n(koren_desno); return 0; }
Stasa Rakic,1,10,"doseg funkcije(tu je vidljivost promenljive u celoj funkciji globalne promenljive) 2-doseg prototipa funkcije (promenljiva je vidljiva samo u deklaraciji funkcije) 3-doseg bloka (promenljiva je vidljiva u bloku,tj izmedju viticastih zagrada, npr u for petlji,lokalne promenljive) 4-doceg datoteke(promenljiva vidljiva u celoj datoteci)"
Stasa Rakic,2,10,Char ima 8 bita tako da bi anulirali elemente na neparnim pozicijama radimo x | (160). Maksa je broj 160 zapravo izgleda ovako 10101010. I da bi invertovali bitove na parnim pozicijama uradimo sa istom maskom operaciju ^. Znaci (x|(160))^160
Stasa Rakic,3,5,"Vremenska slo≈æenost narednog koda je O(m), a prostorna je otprilike O(m/3), ynaci linearna."
Stasa Rakic,4,0,"Rekurzivna funkcija poziva samu sebe, a totalno rekurzivna funkcija je ona koja na kraju vraca samo tu funkciju , npr int f(int m){ if(m==0) return 1; else{ m=m-1; return f(m); } } npr za f(3) f(0) f(1) f(2) f(3) popunjava se po principu LIFO;"
Stasa Rakic,5,5,"Vremenska slozenost je O(2 na n), tj eksponencijalna jer se u svakom koraku izvrse jos 2 poziva na funkciju a prostorna je takodje eksponencijalna jer se cuvaju podaci x,y pri svakom pozivu funkcije(bila bi otp slozenosti 2 na (n+1) priblizno )."
Stasa Rakic,6,8,Posto nam je l=0 d=n-1 (tj d je 7) i s je celobrono deljenje s=(l+d)/2 (tj. s je 3) znaci da se pretrazuju broj 13 i 18 tj posle provere broja 13 odmah se l pomera na s+1 i bas tu nadje broj 18.
Stasa Rakic,7,10,Najcesca greska je curenje memorije koja nastaje usled gubitka adrese podataka. Takodje nepravilno koriscenje funkcije free npr free(p+1). Moze se javiti greska npr ako se ne isprazni memorija funkcijom free. Takodje nije preporucljivo prizivati vise puta funciju free na za isti prostor i koristiti taj prostor nakon koriscenja te funkcije.
Stasa Rakic,8,2,"Void je neoznaceni tip i kostimo ga za funkciji qsort, jer posle mozemo odrediti tacno koji tep zelimo, tj mozemo da kastujemo."
Stasa Rakic,9,5,"Glavna razlika izmedju steka i reda je nacin ""popunjavanja"". Stek ide po principu LIFO gde se prvo eliminise zadnji element koje je dodat (princip gajbica i voca), dok se red popunjava na principu FIFO u kom se prvo eliminise element koj je prvi ubacen (npr red u prodavnici). Funkcije koje koristi stek je push i pop, funkcije koje koristi red su add i get."
Stasa Rakic,10,0,"Dodavanje cvora se odvija tako sto se napravi prvo cvor a zatim se poveze preko pokazivaca sa listom stabla. Posto je stablo binarno uredjeno, to znaci da su elementi sortirani tako da je leva grana element manji od korena a desna grana element veci od korena."
Stasa Rakic,11,10,"Postoje dva nacina obilaska stabla, u dubinu i u sirinu. Obilazak u dubinu izgleda tako sto se ide do dna pa se onda predje na sledecu granu (preko steka) i tu imamo tri nacina na koji to mozemo da radimo 1-infiksno (LKD) 2-prefiksno(KLD) 3-postfiksno(LDK) u zavisnosti od toga sta nam treba (npr postfiksno koristimo uvek za brisanje stabla). Drugi nacin obilaska je kroz nivoe i radi se pomocu redova. Proces izgeda tako ste se prvo upise koren pa onda njegovi potomci, zatim se koren obrise, pa se dodaju njegovi potomci. Ovaj metod je efikacan jer se oslobadja memorija pa ne zauzima puno mesta."
Stasa Rakic,12,0,